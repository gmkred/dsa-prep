Dynamic Programming
Those who does not remember  the past are condemned to repeat it

When ever we try to solve same problem again, agian in recursion, its called overlapping subproblems.
This is where memoization comes 

Memoization : 
---------------
Top down
--------
we tend to store the values of sub problems in some Map/Table.
based on parameters, if there is one parameter, we use 1D array.
example with fibonnaci recursion of 5
			f(n-1)+f(n-2)
				5
			 4	             3
         3       2   	  2     1
       2   1   1   0    1   0  
     1   0
 if we observe, there are sub problems solving fibonnaci(2) 3 times
 each time it returns same value, so why not store the value in an array
 and take the value from there instead of solving it again.
 
DP array		-1 -1 -1 -1 -1 -1
		         _  _  _  _  _  _
		         0  1  2  3  4  5

suppose fibonnaci of 2, return 0+1 = 1 store it at 2nd index

-1 -1  1 -1 -1 -1
 _  _  _  _  _  _
 0  1  2  3  4  5

fibonnaci of 3 retruns, 0+1+1 = 2,store it in 3rd index.

-1 -1  1  2 -1 -1
 _  _  _  _  _  _
 0  1  2  3  4  5

so next time instead of solving for 2 and 3 we can take values from array which will save the time. 

*****Steps to follow*******
1. Declare a DP array with [n+1].
	becasue array is index based;
2. DP[n] should store the final value.
3. For each recursion, check if same sub problem previously solved, if yes just take the value.



Tabulation :
-------------
Bottom up
---------
Go from the base case to the required.

steps :
1. declare DP array [n+1]
2. dp[0] =0 and dp[1] = 1 for fibonnaci.
3. Instead of recursion we use loop starting from 2 for fibonacci.
	for(int i =2;i<=n;i++){
		dp[i] = dp[i-1]+dp[i-2];
	}
this is how we can make tabulation.


How to find a DP problem:

1. Count the total no of ways
2. Max or min steps

Like try all possible ways, thats whe we try to apply recursion.


********Trick :
1. try to represent the problem in terms of index.
2. Do all possible stuff on that index according to problem statement.
3. sum of all stuff or count all ways or min of all steps kind of problems.
		


1D arrays : 
express every thing as indexes
dp[n]

2D arrays :
express everything as rows and columns indexes.
dp[rows][columns]

3D problem
express everything as i1,j1 and i2,j2
Explore all the paths

Base case:
out of bound and destination reach.

j1 < 0 || j1 >= col || j2 < 0 || j2 >= col
return minimum numnber, but do not take MIN_VALUE

******But we need only 1 row reference i, becasue when we move to next row, both pointer will be on same row.


if there is a fixed point and variable points recommended to take start from the fixed point



****** 0/1 KNAPSACK
-------------------

Verrrrrrrrryyyyy Important.

What is knapsack ?

N=3, each item has particular weight and a value.

weight	3	4	5
value	30	50	60

Thief bag can only carry weight 8.
Maximum value with given weight thief can steal.
{4+5} = 9 X weight is not in bags range
{50+60} = 110 

{3+4} = 7 <=8 Possible
{30+50} = 80 this is the maximum value thief can steal.

Greedy wont work because it has no uniformity.

so we sue recursion:

Steps :

1. Express the problem in terms of array. [index, value]
2. Explore all possibilities. Pick / Not pick.
3. Max(all possibilities)


